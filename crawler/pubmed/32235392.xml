<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE collection SYSTEM "BioC.dtd">
<collection><source>PMC</source><date>20201223</date><key>pmc.key</key><document><id>7180584</id><infon key="license">CC BY</infon><passage><infon key="article-id_doi">10.3390/s20071900</infon><infon key="article-id_pmc">7180584</infon><infon key="article-id_pmid">32235392</infon><infon key="article-id_publisher-id">sensors-20-01900</infon><infon key="elocation-id">1900</infon><infon key="issue">7</infon><infon key="kwd">fog computing edge computing testbed mobile crowdsourcing Internet of things IoT</infon><infon key="license">Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (http://creativecommons.org/licenses/by/4.0/).</infon><infon key="name_0">surname:Xu;given-names:Qiaozhi</infon><infon key="name_1">surname:Zhang;given-names:Junxing</infon><infon key="name_2">surname:Togookhuu;given-names:Bulganmaa</infon><infon key="section_type">TITLE</infon><infon key="type">front</infon><infon key="volume">20</infon><infon key="year">2020</infon><offset>0</offset><text>Support Mobile Fog Computing Test in piFogBedII</text></passage><passage><infon key="section_type">ABSTRACT</infon><infon key="type">abstract</infon><offset>48</offset><text>IoT and 5G technologies are making smart devices, medical devices, cameras and various types of sensors become parts of the Internet, which provides feasibility to the realization of infrastructure and services such as smart homes, smart cities, smart medical technology and smart transportation. Fog computing (edge computing) is a new research field and can accelerate the analysis speed and decision-making for these delay-sensitive applications. It is very important to test functions and performances of various applications and services before they are deployed to the production environment, and current evaluations are more based on various simulation tools; however, the fidelity of the experimental results is a problem for most of network simulation tools. PiFogBed is a fog computing testbed built with real devices, but it does not support the testing of mobile end devices and mobile fog applications. The paper proposes the piFogBedII to support the testing of mobile fog applications by modifying some components in the piFogBed, such as extending the range of end devices, adding the mobile and migration management strategy and inserting a container agent to implement the transparent transmission between end devices and containers. The evaluation results show that it is effective and the delay resulting from the migration strategy and container agent is acceptable.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_1</infon><offset>1436</offset><text>1. Introduction</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>1452</offset><text>IoT and 5G technologies are making smart devices, medical devices, cameras and various types of sensors become parts of the Internet, which provides feasibility to the realization of infrastructure and services, such as smart homes, smart cities, smart medical technology and smart transportation; and the amount of data they generate is also extremely huge, which challenges the traditional storage and data analysis methods. Cloud computing provides solutions for massive data storage and processing by providing on-demand and scalable resources. However, the high latency is unacceptable for health monitoring, emergency response and other delay-sensitive applications. In addition, it will make the network bandwidth saturated, and the scalability is poor for sending massive datasets to the centralized cloud platform.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>2276</offset><text>Cisco first proposed the concept of fog computing (also known as edge computing) to solve these problems by deploying lightweight computing and storage resources near the end devices, processing and analyzing the data they generated to reduce network congestion, thereby accelerating the analysis speed and decision-making. These lightweight computing resources are called fog. The fog cannot exist independently from the cloud; it offsets and enhances the cloud computing and can be deployed anywhere between end equipment and clouds. As parts of the network, fogs can be routers, switches, servers or mobile stations, and they provide lower delay than cloud computing. Applications such as flow processing, virtual reality/augmented reality, smart traffic control, smart homes and smart cities can benefit from fog computing.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>3104</offset><text>Fog computing is a new research field, and it is very important to test the functions and performances of various applications and services before they are deployed to the production environment. However, current evaluations are more based on various simulation tools— FogNetSim++, iFogSim, EdgeCloudSim, etc.—which usually leads to a large difference between the experimental results and the actual situation. A more realistic testing environment can help users find the bottle neck, defect or limitation of their applications. We have designed piFogBed based on raspberry pies, which is a real fog computing testbed that can provide a real fog computing architecture, simulate various network scenarios for users and support users’ testing of real applications. The experimental results obtained on piFogBed have better fidelity than simulators, but, the flexibility and scalability of piFogBed were poor in the following aspects:</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>4043</offset><text>(1) The scalability of the end devices is insufficient. In piFogBed, end devices are provided by experimental users, which guarantees their security and privacy, but, for large fog applications such as smart transportation and smart cities, more end equipment is needed, and the self-supply mode will increase users’ costs greatly.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>4377</offset><text>(2) It did not support the testing of mobile applications. The end equipment in piFogBed is connected to a fog node fixedly and cannot move and switch among multiple fog nodes, so the applications can be tested are limited, because there is not a mobility management strategy for the end equipment. But for many fog applications, such as virtual reality, smart transportation and online games, the mobility is a common characteristic.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>4812</offset><text>(3) Users cannot select fog nodes freely. piFogBed automatically selects fog nodes for a user based on the position of his/her end equipment to avoid resource waste, which may lead to a large deviation from users’ actual requirements; in addition, if a user only has a few end devices, he can only apply for fewer fog nodes, which limits the user’s testing tasks.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>5180</offset><text>(4) End devices’ access to a container was not transparent. piFogBed supports running multiple testing tasks on a fog node by using the docker container technology. For a testing task, it may deploy applications on several fog nodes, but the ports mapped to the applications on different fog nodes are not always selfsame, so the user must store each ports on different fog nodes. When an end device logs on a new fog node, it needs to change the connection port, and that increases the user’s workload, especially for mobile applications, which is unacceptable. In addition, it will bring security risks for the internal containers.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>5818</offset><text>To resolve these problems, we modify the piFogBed and propose the piFogBedII to support mobile application testing, expand the scope of end equipment, support a user’s selection of fog node more freely and insert a container agent between external devices and internal containers to make their data transmission transparent, which not only guarantees the security of internal containers, but simplifies users’ work.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>6238</offset><text>The rest of the paper is organized as follows. Section 2 presents related work. Section 3 introduces the new components in piFogBedII. Section 4 presents the implementation of mobile application testing. Section 5 evaluates the effectiveness. The conclusions and future work are presented in Section 6.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_1</infon><offset>6541</offset><text>2. Related Work</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>6557</offset><text>Currently, simulation tools are used by many researchers for testing and evaluating fog applications or services because of the low cost and ease of use.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>6711</offset><text>FogNetSim++ is a fog simulator designed based on OMNET++, which provides users with detailed configuration options to simulate a large fog network, and allows researchers to integrate specific mobile models, fog node scheduling algorithms and management handover mechanisms. It is scalable and effective in CPU and memory usage, but does not support virtual machine migration among fog node.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>7103</offset><text>iFogSim is based on CloudSim, and it allows users to simulate the fog computing infrastructure and execute simulation applications to test the performance of delay and energy consumption. iFogSim can simulate edge devices, cloud data centers, sensors, network links, data flows and flow processing applications. It integrates simulation services of power monitoring and resource management, and supports cloud deployment and edge deployment of applications. But the location of end devices is static and cannot be updated; on the other hand, it is limited to the discrete event simulators (DES) and has very poor scalability because of the characteristics of CloudSim. Myifogsim extends iFogSim to support mobility by migrating virtual machines between cloudlets. In, Naas extends iFogSim to implement data deployment strategy in fog and IoT.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>7946</offset><text>EdgeCloudSim is another fog simulation tool based on CloudSim. It is designed to assess the computing and network requirements of edge computing. EdgeCloudSim supports mobility by providing mobile models, network link models and edge server models. pFogSim extends EdgeCloudSim to include different networks, applications and business process models. IoTSim is also designed to simulate an edge computing environment in which IoT applications send large amounts of data to big data processing systems. As a result, it adds storage and big data processing layers to CloudSim. EdgeCloudSim and IoTSim both inherit the same scalability and DES limitations as iFogSim.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>8611</offset><text>Brogi recently extends the FogTorch and proposes the FogTorchII simulator. It can evaluate the deployment of fog computing infrastructure, and model software functions, hardware functions and QoS attributes, but its scalability is poor.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>8848</offset><text>RECAP supports the modeling for complex and specific requirements to find the best solution for resource management in edge computing systems, but it is difficult to manage and configure, and is not easy to expand or modify.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>9073</offset><text>VirtFogSim is a software toolbox based on matlab, and it is limited to optimizing and tracking the energy and delay performance of task offloading.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>9221</offset><text>Sphere is based on SCORE, and can create a cloudlet network based on graph; generate dynamic and parallel workloads; and specify the geographic location, resource density and deployment requirements of workload. But it does not support the mobility of nodes and lacks the migration model of a workload.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>9524</offset><text>Simulation tools simplify the evaluation process, but the differences between the simplified scene and the production environment are very large, especially for the dynamic fog computing scene; the experimental results may be infidelity. Network emulation can solve some problems of simulation to a certain extent and improve the fidelity of experimental results to a certain extent. </text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>9909</offset><text>Emufog is an emulation framework designed for fog computing, in which fog nodes are simulated by the maxinet, and applications run in the docker containers. Emufog is more realistic than simulation tools, but it does not support the mobility of clients and fog nodes. </text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>10178</offset><text>Fogbed extends the mininet, uses docker containers as virtual nodes and provides the function of building cloud and fog testbeds. It allows users to dynamically add, connect and delete containers in the network topology to simulate the phenomenon of computing instances start and end at any time in the real world cloud and fog environments, but it does not support the management of mobility, security, fault tolerance, scalability and reliability.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>10628</offset><text>Cumulus is a distributed edge computing testbed, but it mainly focuses on task offloading, without considering the whole edge computing system, network topology, network delay and mobility.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>10818</offset><text>Compared with simulation and emulation, the fidelity of an overlay network built with real equipment in a real network is the best. However, it is high cost and difficult to build a real fog computing testbed because the fog equipment produced by different manufacturers is not compatible, and the price is high. We have built the piFogBed using raspberry pies, but it does not support the mobility of end devices. </text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11234</offset><text>Adding mobile and migration management for end devices;</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11290</offset><text>Expanding the range of end devices;</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11326</offset><text>Supporting a user’s selection of fog nodes freely;</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11379</offset><text>Inserting a container agent between internal containers and external devices to make their interaction transparent.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11495</offset><text>Therefore, we modify the piFogBed for supporting the mobility of end devices and name it piFogBedII. We modify piFogBed mainly from four aspects:</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_1</infon><offset>11641</offset><text>3. New Components in piFogBedII</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_2</infon><offset>11673</offset><text>3.1. Crowd End Devices</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11696</offset><text>Similarly to piFogBed, piFogBedII only provides fog nodes and cloud nodes for users; the difference is that piFogBedII extends the use and scope of end devices in the piFogBed.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>11873</offset><text>Considering the diversity, vulnerability and mobility of end devices, piFogBedII does not provide end devices for users too. Users can either use their own end devices, or employ volunteers and utilize crowdsourcing devices to expand the end equipment. These crowd devices can participate in an experiment as long as they can login on the fog nodes through Wi-Fi and run the end worker app and users’ testing app. As a result, piFogBedII is not only more abundant in the number and types of end devices, but also provides the feasibility for mobile fog application testing.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_2</infon><offset>12449</offset><text>3.2. Logical Components</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>12473</offset><text>In piFogBedII, we improve the device management module and allocation method of fog node in the coordinator; moreover, it modifies the way an end device accesses containers and adds mobile management in fog nodes to support mobile fog application testing. The components of piFogBedII are shown in Figure 1, and are the same as those of piFogBed; we still use docker containers to deploy users’ experimental applications on fog nodes and cloud nodes because of certain of their characteristics: open source, light weight, fast startup and small resource consumption. In the following, we mainly introduce the modules which are not included in the piFogBed.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>13132</offset><text>(1) Experiment publisher and experiment subscriber. piFogBedII introduces the crowdsourcing devices into the testbed, so it is important to notify the newest experiment information to crowd users in time. The experiment publisher on the coordinator receives a user’s descriptions about his experiment and publishes the information to some crowd users who are interested in this type experiment to attract them to participating into the experiments. The experiment subscriber runs on crowd end devices, and helps crowd users to subscribe and receive the experiment information published by the experiment publisher that they are interested in.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>13777</offset><text>(2) Container agent. To ensure the transparent access and security of the fog/cloud nodes, we utilize a container agent to isolate the direct interaction of external devices and internal docker containers in fog nodes and cloud nodes. For fog nodes, the container agent receives testing data from end devices or other fog nodes. The testing data flow is produced by the testing app running on the end devices and sent to the container agent running on a fog node; then the container agent transfers the data to a corresponding docker container. When a container running in a fog node wants to send data to another container running in another fog node or cloud node, it should transfer the data to its local container agent, and then the local container agent will connect to the container agent on the destination node and transfer the data to it, so the container agent is the bridge between end devices and internal containers or among containers.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>14728</offset><text>(3) Migration monitor and migration controller. The two modules run on end devices and fog nodes respectively. The migration monitor sends the received signal strength from itself to its current connected fog node; if it finds the signal strength is lower than a threshold, it will send a migration request to another fog node with the largest signal strength.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_2</infon><offset>15089</offset><text>3.3. Experiment Stages</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>15112</offset><text>There are four steps to executing an experiment on the piFogBedII, as shown in Figure 2, and we illustrate them with a simple example. </text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>15248</offset><text>Assuming an experimental user develops an edge application to count, in real-time, pedestrian volume passing a road, and he wants to test the function and performance of each part of the application. We suppose that the application consists of three modules: a data aggregate module running on the cloud node, a pedestrian flow collection module running on several fog nodes and a client app running on users’ end devices. As the end device is moved, the client app will connect to the pedestrian flow collection application running on the fog node; each fog node periodically sends the statistical data to the data aggregate module running on the cloud node. Suppose that the user has generated two docker images, which include the data aggregate module and data collection module respectively, and stored them on the Doker Hub, which is the world’s largest library for docker container images. The two images will run on a cloud node and several fog nodes, respectively, later. The user wants to utilize mobile crowdsourcing devices to continuously count the pedestrian volume of a road during a period of time, so he publishes the purpose and demand of the experiment to the piFogBedII platform in advance, which will push the experiment information to users who subscribe to that type of experiment. All end devices participating in the experiment must be installed the endworker, registered on the piFogBedII. Then, the user carries out his experiment according to the following four stages.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_3</infon><offset>16749</offset><text>3.3.1. Preparation of an Experiment</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>16785</offset><text>Firstly, the user views the real-time status of every fog node and cloud node in the test bed through the web, including CPU and memory utilization and the number of experiments running on them currently, and for fog nodes, he can also view their geographical positions. </text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>17057</offset><text>Secondly, the user selects appropriate fog nodes according to the experimental requirement. For the above example, the user can select several fog nodes along the road which have enough resources to run the experiment, assuming they are . For cloud nodes, the user gives the number he needs, and then the system allocates the cloud node to him automatically to avoid resource wasting; for example,  in this case. After selection, the user can make a reservation for these devices to avoid them being occupied by other users.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>17582</offset><text>Finally, each end device (including private devices and crowdsourcing devices) participating in the experiment must be installed user’s client app, and connected to one of the fog nodes selected by the user.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_3</infon><offset>17792</offset><text>3.3.2. Deployment of an Experiment</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>17827</offset><text>Create experiment: The user sends a request to the coordinator to create an experiment. The coordinator creates a new experiment in the database for the user and returns the expId to the user.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>18020</offset><text>Deploy image: The user sends the name of the docker image stored in the docker hub to the coordinator, which will be started on the selected fog nodes (here,) and cloud nodes (here, ). The coordinator sends the image name to the corresponding cloud nodes (here, ) and fog nodes (here, ), and then these nodes download the specified image from the docker hub and startup the container according to the requirement. Let  and  denote the containers started on  and  respectively for the example.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>18513</offset><text>Network configuration: After all containers started successfully, the user set the upper containers for containers in the fog nodes. The upper containers may be on another fog node or a cloud node to act for data aggregation. In this example, the upper container of  in  is. Secondly, the user sets different delays, bandwidths and losses for different networks link to emulate various Wan scenarios in the LAN environment; for example, the network parameter between  and  may have or other values. Then the coordinator sends the topology relationship and emulation parameters to every fog node; for example, tellingthat the upper container of the container  is  and the emulation parameters between them are. Finally, each fog node converts these parameters into one or more traffic control rules which can control the net link between a specific docker container running on local and another docker container running on another node. The testing applications are running in the containers; for instance, the aggregate module runs in the containerand the collection module runs in the container ; then the link between  and  will be shaped by the TC rules.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>19671</offset><text>There are three steps for users to deploy an experiment: </text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_3</infon><offset>19729</offset><text>3.3.3. Execution of an Experiment</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>19763</offset><text>Firstly, the participants login their end devices on one of the fog nodes through the endworker. Secondly, they run the client application on their end devices, and the experimental data is sent to the container agent in the fogworker on the fog node , which will be forwarded to a specific container (such as  in this example) later. The container (such as ) in the fog node  transfers the collection data to its upper container () periodically.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>20210</offset><text>During the progress, some end devices may move and leave the coverage range of the current fog node. The endworker running on end devices monitors the received signal strength to its fog node and sends a migration request to a fog node with the largest signal strength when it finds the current signal strength is lower than a threshold, and completes the migration when it finds the current fog node has switched.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>20625</offset><text>When a participant wants to exit the experiment, he sends an exit request to its fog node through the endworker, and the fog node deletes its information and reports to the coordinator.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>20811</offset><text>At this stage, the experimental user can view current status and relevant information of his experiment through the coordinator.</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">title_3</infon><offset>20940</offset><text>3.3.4. Termination of an Experiment</text></passage><passage><infon key="section_type">INTRO</infon><infon key="type">paragraph</infon><offset>20976</offset><text>The experimental user sends a request to the coordinator if he wants to terminate the experiment, which notifies all fog nodes and cloud nodes in his experiment to close the containers (such as ) and release resources. The fog nodes notify the connected end devices and disconnect from them. In addition, the fog nodes remove the traffic control rules relative to the experiment.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_1</infon><offset>21356</offset><text>4. Implementation of Mobile Fog Application Testing</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>21408</offset><text>To support mobile fog application testing, piFogBedII needs to solve two problems: (1) migrations of end devices among fogs; (2) transparent data transmission between end devices and docker containers.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_2</infon><offset>21610</offset><text>4.1. Some Key Data Structure</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>21639</offset><text>There are three key data structures in the piFogBedII, as shown in Figure 3. The ExperimentsList is maintained by the coordinator, which contains all experiments running on the platform currently. The expList is on every fog node and cloud node, which stores the experiments running on it currently. The endList is on the fog node too, which stores the end devices participating in the experiments running on it.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_2</infon><offset>22052</offset><text>4.2. Migration of End Devices</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>22082</offset><text>PiFogBedII extends the end devices, including not only users’ private devices, but also the crowd devices. Crowdsourcing resources enrich the number and types of the end device, and solve the mobility of end devices. However, an end device may move and leave the coverage range of its current fog node, which results in the failure of data transmission. Therefore, the end device must search for a new fog node and complete the migration from the old fog node to the new one, and the function is completed by the migration monitor component in the endworker.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>22643</offset><text>The migration monitor periodically detects the signal strength from itself to the current fog node (). If the signal strength is lower than the migration threshold , it searches a fog node with the strongest signal strength as its target fog node ().</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>22894</offset><text>The migration monitor sends a migration request to the target, and the request data contains the endId and experimentId which are the unique identifiers of the end device and the experiment of the device participated in at that time.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>23128</offset><text> searches the experimentId in the expList. If the result is null, the  refuses the request because the experiment does not run on the fog node and it cannot provide service for the end device; otherwise, it searches the endId in the endList, and if the result is not null, that indicates the end device has logged in and participated in the experiment on  some time ago, so the  accepts the migration request directly. If the result is null,  validates the end device to the coordinator.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>23616</offset><text>If the result returned from the coordinator is successful,  sends an acceptance response to the end device; meanwhile, it adds endId into its endList; otherwise, it sends a rejection response to the end device.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>23827</offset><text>The end device modifies as its new fog node after it receives the acceptance response.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>23914</offset><text>The migration request from end devices is processed by the migration controller on the fog node, and we use the reliable transmission technology based on socket to implement the data transmission between them.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>24124</offset><text>We implement the migration monitor based on the WifiManager which is a class provided by the android API for the developer to manage all aspects of Wi-Fi connectivity of android devices. The signal will be very weak when the received signal strength indicator (RSSI) is lower than −90 dbm, so we use  to denote the migration threshold; i.e., the end device will start to seek a new fog node with the largest RSSI as the migration target if its current. The whole migration progress is shown in Figure 4, which is divided into five steps: </text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_2</infon><offset>24665</offset><text>4.3. Implementation of Transparent Access</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>24707</offset><text>Container technology provides a resource isolation environment for multiple applications running on a host at the same time, so that the applications in different containers do not affect each other. In general, a container should open one port at least for data transmission, which will be mapped to a port outside the container. When end devices migrate among different fog nodes, there exists the problem that the same applications in different containers and different fogs are not always mapped to stationary external ports, which not only increases users’ workloads and reduces their experiences, but also exposes the internal containers to outside, which may bring security risks and threats to the containers and fog nodes.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>25441</offset><text>To solve the problem, we design and implement a container agent in the fog node and cloud node to enable the transparent data transmission between external devices and internal containers, as shown in Figure 5. The communications between other devices and container agent are implemented using socket technology. There are two components in the container agent; the SR is a server and the CT is a client. The SR listens at a port and processes requests from other devices or internal containers, and then invokes the CT to send data to the destination. For the data from end devices, the SR obtains the experimentId and the containerId corresponding to the endId of the end devices by searching endList and expList (in Figure 3), then sends (containerId, data) to the CT. For the data from internal containers (for example container A in the Figure 5), the SR obtains the experimentId corresponding to the containerId through searching expList, then sends (experimentId, data) to the CT. The CT sends the data to a internal container if it receives the containerId; otherwise, it sends the data to another container agent running on the upper node of the current node. The CT maintains a long socket connection to every internal container running on the local fog node to save the time of establishing connection with the internal containers and reduce the impact on the transmission delay.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_2</infon><offset>26832</offset><text>4.4. Crowdsourcing Devices</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>26859</offset><text>Crowdsourcing is an effective way to solve difficult tasks, and has been widely used in many fields. With the popularity of mobile devices equipped with various built-in sensors, mobile crowdsourcing has become an important branch of the crowdsourcing field. We introduce the mobile crowdsourcing into the piFogBedII to enrich the end devices, and solve the problems of mobility, high cost, and limited numbers and types of end devices.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>27296</offset><text>A typical mobile crowdsourcing system is composed of a task publisher, a platform and many mobile users (workers). The platform publishes publishers’ tasks to mobile users, and then mobile users select and complete a task using their mobile devices. In piFogBedII, experimental users are task publishers, and end devices are task workers, and the experiment publisher module publishes experimental tasks to crowd mobile devices.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>27727</offset><text>Mobile crowdsourcing allows mobile users to perform tasks that are in their interests and on their behalf. Experimental users describe their experimental tasks through four attributes to enable mobile users to understand and participate in an experiment according to their interests and plans. We assume:</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28032</offset><text>: Experiment i that requiring crowdsourcing resources.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28087</offset><text>Four tuples: 4 attributes of an experiment, and:</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28136</offset><text>: the type of the experiment, data collection or computing;</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28196</offset><text>: the execution duration of the experiment, short or long;</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28255</offset><text>: the resource occupation of the experiment for the end device;</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28319</offset><text>: the reward for participating in the experiment.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28369</offset><text>These attributes are all descriptive characteristics, so we digitize these attributes to make convenient the calculation the type of an experiment, as shown in the Figure 6, and for each attribute, only one position can be set as 1.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28602</offset><text>For an experiment  and its attributes submitted by the experimental user, we use Equation (1) to calculate its type, and it will be a positive integer of 2 bytes. In the equation,  represents the bit position and  represents the value of that position. For example, if the attributes tuple is set as , then the experiment type will be 1290. </text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>28944</offset><text>We adopt the publish/subscribe model to enable crowdsourcing users to receive the interested tasks in time, as shown in Figure 7. According to the attributes of an experimental task, crowdsourcing users subscribe to the types attracted him. There are types, so there are 36 queues and user groups. The experiment publisher routes the experiment information to the respective queue and push them to all crowdsourcing end devices in the group according to the experiment type value.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>29425</offset><text>We use MQTT protocol to realize message pushing. MQTT is a publish/subscribe, simple and lightweight messaging protocol, designed for constrained devices and low-bandwidth, high-latency or unreliable networks. MQTT provides one-to-many message publishing based on the Transmission Control Protocol (TCP). The implementation of MQTT requires the communication between the client and server, and in the process of communication, there are three roles: publisher, broker (server) and subscriber. Among them, the publisher and subscriber are both clients, the message broker is the server and the message publisher can be the subscriber at the same time. The messages transmitted by MQTT are divided into two parts: topic and payload. Topic is the type of a message; the subscribers will receive the message content (payload) of a topic after they subscribe, and in piFogBedII, there are 36 topics corresponding to 36 queues of Figure 7; payload is the content of a message, and refers to the specific content to be used by subscribers; here, the experimental description is the payload. MQTT builds the underlying network transmission and establishes connections for clients and the server, and provides them with orderly, lossless, bidirectional transmission.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>30683</offset><text>In piFogBedII, we build the MQTT server based on Apollo which is a messaging broker built from ActiveMQ. The experiment publisher in the coordinator parses the experiment requirements and calculates their type value, and then as the publisher, publishes them to the corresponding topic on the Apollo broker; end devices, as the subscribers, receive the experimental information of related topics pushed by the Apollo broker later.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_1</infon><offset>31114</offset><text>5. Evaluation</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>31128</offset><text>We have verified the availability and fidelity of piFogBed in. We will evaluate the performances of the migration strategy and container agent in piFogBedII.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_2</infon><offset>31286</offset><text>5.1. Migration Strategy</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>31310</offset><text>In the experiment, we test the migration delay. The experimental deployment is shown in Figure 8. We deploy four raspberry pies in four laboratories as fog nodes. Among them, f1, f2 and f4 run the experiment, while f3 in Lab 3 does not run the experiment. A student holds a smart phone and logs on the f1 from Position 1, and then slowly walks along the corridor to Position 4 and then returns to Position 1. The phone sends migration requests at Positions 2, 3 and 4 respectively, and we test the time from sending request to receiving feedback in each location, and the results are shown in Figure 8.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>31913</offset><text>We test the time spent with no migration strategy used and fog switched manually, mostly over 1000 ms, and we use 1000 ms to represent them in Figure 9. When the student moves from Position 1 to Positions 2 and 4, it will take longer time than from Position 4 to Position 1, because the device is the first to connect them at those positions, and that needs to be verified to the coordinator. In addition, the time spent is shorter at Position 3, because f3 does not run the experiment and directly rejects the request. For the first connection at Position 1, the student needs to log in manually, so it takes a long time.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>32536</offset><text>The experiment proves that the migration process is almost transparent to the user. As long as the experimental user selects appropriate fog nodes, and sets distances between them in appropriate ranges, the mobility of end devices between different fog nodes has little impact on its data transmission, which provides the basis for supporting the mobile fog application testing.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">title_2</infon><offset>32915</offset><text>5.2. Performance of Container Agent</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>32951</offset><text>We evaluate the impact of the container agent on the delay through this experiment. Firstly, we start a container on a fog node and run a server program in the container which feeds back the current time to the user. Then we run a multithreaded client program on a PC to simulate multiple end devices to request the current time from the server program. We test the time spent by the client from sending the request to receiving the feedback under different numbers of threads in the cases of direct access and indirect access with a container agent, and the results are shown in the Figure 10. We find that using the container agent to forward data increases the waiting time from the minimum 3.3 ms to the maximum 25.4 ms, but we think that is acceptable for users.</text></passage><passage><infon key="section_type">METHODS</infon><infon key="type">paragraph</infon><offset>33719</offset><text>Finally, we test the impact of the container agent on the user’s waiting time under different transmission data amounts. We use 10 threads to simulate 10 end devices sending different sizes of data to the server program at the same time. We test the time spent from the data sent by the client to receiving response under the conditions of access directly and via the container agent, respectively. The results are as shown in the Figure 11. It can be seen that when there is a large amount of data, the container agent needs to receive data and forward it to the server in the container and it will take a certain time. In our test, the minimum is about 50 ms, and the maximum is about 100 ms. However, the container agent provides users with transparent access to the container; otherwise, users need to connect manually, which takes time longer. We will study more efficient mechanisms to shorten the time of the container agent.</text></passage><passage><infon key="section_type">CONCL</infon><infon key="type">title_1</infon><offset>34654</offset><text>6. Conclusions</text></passage><passage><infon key="section_type">CONCL</infon><infon key="type">paragraph</infon><offset>34669</offset><text>Fog computing (edge computing) is a new research field and the fog computing testbed plays an important role in promoting the integration of cloud and IoT technology and accelerating the development of fog application. piFogBedII provides more feasibility for mobile fog application testing than piFogBed, and in the future, we will further enhance the performance of the testbed.</text></passage><passage><infon key="section_type">AUTH_CONT</infon><infon key="type">title</infon><offset>35050</offset><text>Author Contributions</text></passage><passage><infon key="section_type">AUTH_CONT</infon><infon key="type">paragraph</infon><offset>35071</offset><text>Conceptualization, Q.X.; data curation, Q.X.; formal analysis, Q.X.; funding acquisition, J.Z.; investigation, B.T.; methodology, Q.X.; project administration, J.Z.; resources, Q.X.; software, Q.X.; supervision, J.Z.; validation, Q.X.; writing—original draft, Q.X.; writing—review and editing, J.Z. All authors have read and agreed to the published version of the manuscript.</text></passage><passage><infon key="section_type">ACK_FUND</infon><infon key="type">title</infon><offset>35451</offset><text>Funding</text></passage><passage><infon key="section_type">ACK_FUND</infon><infon key="type">paragraph</infon><offset>35459</offset><text>This research was partially supported by the National Natural Science Foundation of China (grant number 61261019), the Inner Mongolia Science and Technology Plan (grant number 201802027) and the Inner Mongolia Autonomous Region Natural Science Foundation (grant number 2018MS06023).</text></passage><passage><infon key="section_type">COMP_INT</infon><infon key="type">title</infon><offset>35742</offset><text>Conflicts of Interest</text></passage><passage><infon key="section_type">COMP_INT</infon><infon key="type">paragraph</infon><offset>35764</offset><text>The authors declare no conflict of interest.</text></passage><passage><infon key="section_type">REF</infon><infon key="type">title</infon><offset>35809</offset><text>References</text></passage><passage><infon key="name_0">surname:Dastjerdi;given-names:A.V.</infon><infon key="name_1">surname:Buyya;given-names:R.</infon><infon key="section_type">REF</infon><infon key="source">Internet of Things: Principles and Paradigms</infon><infon key="type">ref</infon><infon key="year">2016</infon><offset>35820</offset></passage><passage><infon key="fpage">13</infon><infon key="lpage">16</infon><infon key="name_0">surname:Bonomi;given-names:F.</infon><infon key="name_1">surname:Milito;given-names:R.</infon><infon key="name_2">surname:Zhu;given-names:J.</infon><infon key="name_3">surname:Addepalli;given-names:S.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the First Edition of the MCC Workshop on Mobile Cloud Computing</infon><infon key="type">ref</infon><offset>35821</offset><text>Fog computing and its role in the internet of things</text></passage><passage><infon key="fpage">37</infon><infon key="lpage">42</infon><infon key="name_0">surname:Yi;given-names:S.</infon><infon key="name_1">surname:Li;given-names:C.</infon><infon key="name_2">surname:Li;given-names:Q.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2015 Workshop on Mobile Big Data</infon><infon key="type">ref</infon><offset>35874</offset><text>A survey of fog computing: Concepts, applications and issues</text></passage><passage><infon key="fpage">375</infon><infon key="lpage">387</infon><infon key="name_0">surname:Kim;given-names:D.Y.</infon><infon key="name_1">surname:Kim;given-names:S.</infon><infon key="pub-id_doi">10.32604/cmc.2019.06077</infon><infon key="section_type">REF</infon><infon key="source">Comput. Mater. Contin.</infon><infon key="type">ref</infon><infon key="volume">59</infon><infon key="year">2019</infon><offset>35935</offset><text>A Data Download Method from RSUs Using Fog Computing in Connected Vehicles</text></passage><passage><infon key="fpage">493</infon><infon key="lpage">508</infon><infon key="name_0">surname:Li;given-names:Y.</infon><infon key="name_1">surname:Wang;given-names:X.</infon><infon key="name_2">surname:Fang;given-names:W.</infon><infon key="name_3">surname:Xue;given-names:F.</infon><infon key="name_4">surname:Jin;given-names:H.</infon><infon key="name_5">surname:Zhang;given-names:Y.</infon><infon key="name_6">surname:Li;given-names:X.</infon><infon key="pub-id_doi">10.32604/cmc.2019.05178</infon><infon key="section_type">REF</infon><infon key="source">Comput. Mater. Contin.</infon><infon key="type">ref</infon><infon key="volume">59</infon><infon key="year">2019</infon><offset>36010</offset><text>A Distributed ADMM Approach for Collaborative Regression Learning in Edge Computing</text></passage><passage><infon key="fpage">439</infon><infon key="lpage">463</infon><infon key="name_0">surname:Jo;given-names:B.</infon><infon key="name_1">surname:Piran;given-names:M.J.</infon><infon key="name_2">surname:Lee;given-names:D.</infon><infon key="name_3">surname:Suh;given-names:D.Y.</infon><infon key="pub-id_doi">10.32604/cmc.2019.08194</infon><infon key="section_type">REF</infon><infon key="source">Comput. Mater. Contin.</infon><infon key="type">ref</infon><infon key="volume">61</infon><infon key="year">2019</infon><offset>36094</offset><text>Efficient Computation Offloading in Mobile Cloud Computing for Video Streaming Over 5G</text></passage><passage><infon key="fpage">864</infon><infon key="lpage">872</infon><infon key="name_0">surname:Wang;given-names:T.</infon><infon key="name_1">surname:Zeng;given-names:J.</infon><infon key="name_2">surname:Lai;given-names:Y.</infon><infon key="name_3">surname:Cai;given-names:Y.</infon><infon key="name_4">surname:Tian;given-names:H.</infon><infon key="name_5">surname:Chen;given-names:Y.</infon><infon key="name_6">surname:Wang;given-names:B.</infon><infon key="pub-id_doi">10.1016/j.future.2017.07.031</infon><infon key="section_type">REF</infon><infon key="source">Future Gener. Comput. Syst.</infon><infon key="type">ref</infon><infon key="volume">105</infon><infon key="year">2020</infon><offset>36181</offset><text>Data Collection from WSNs to the Cloud based on Mobile Fog Elements</text></passage><passage><infon key="fpage">62</infon><infon key="name_0">surname:Wang;given-names:T.</infon><infon key="name_1">surname:Luo;given-names:H.</infon><infon key="name_2">surname:Zheng;given-names:X.</infon><infon key="name_3">surname:Xie;given-names:M.</infon><infon key="pub-id_doi">10.1145/3324926</infon><infon key="section_type">REF</infon><infon key="source">Acm Trans. Intell. Syst. Technol.</infon><infon key="type">ref</infon><infon key="volume">10</infon><infon key="year">2019</infon><offset>36249</offset><text>Crowdsourcing Mechanism for Trust Evaluation in CPCS based on Intelligent Mobile Edge Computing</text></passage><passage><infon key="fpage">69524</infon><infon key="lpage">69534</infon><infon key="name_0">surname:Wang;given-names:B.</infon><infon key="name_1">surname:Kong;given-names:W.</infon><infon key="name_2">surname:Guan;given-names:H.</infon><infon key="name_3">surname:Xiong;given-names:N.N.</infon><infon key="pub-id_doi">10.1109/ACCESS.2019.2917277</infon><infon key="section_type">REF</infon><infon key="source">IEEE Access</infon><infon key="type">ref</infon><infon key="volume">7</infon><infon key="year">2019</infon><offset>36345</offset><text>Air Quality Forcasting based on Gated Recurrent Long Short Term Memory Model in Internet of Things</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">14</infon><infon key="name_0">surname:Zhou;given-names:Z.</infon><infon key="name_1">surname:Liao;given-names:H.</infon><infon key="name_2">surname:Gu;given-names:B.</infon><infon key="name_3">surname:Mumtaz;given-names:S.</infon><infon key="name_4">surname:Rodriguez;given-names:J.</infon><infon key="pub-id_doi">10.1109/TETCI.2019.2902869</infon><infon key="section_type">REF</infon><infon key="source">IEEE Trans. Emerg. Top. Comput. Intell.</infon><infon key="type">ref</infon><infon key="year">2019</infon><offset>36444</offset><text>Resource Sharing and Task Offloading in IoT Fog Computing: A Contract-Learning Approach</text></passage><passage><infon key="fpage">63570</infon><infon key="lpage">63583</infon><infon key="name_0">surname:Qayyum;given-names:T.</infon><infon key="name_1">surname:Malik;given-names:A.W.</infon><infon key="name_2">surname:Khattak;given-names:M.A.K.</infon><infon key="name_3">surname:Khalid;given-names:O.</infon><infon key="name_4">surname:Khan;given-names:S.U.</infon><infon key="pub-id_doi">10.1109/ACCESS.2018.2877696</infon><infon key="section_type">REF</infon><infon key="source">IEEE Access</infon><infon key="type">ref</infon><infon key="volume">6</infon><infon key="year">2018</infon><offset>36532</offset><text>FogNetSim++: A Toolkit for Modeling and Simulation of Distributed Fog Environment</text></passage><passage><infon key="fpage">1275</infon><infon key="lpage">1296</infon><infon key="name_0">surname:Gupta;given-names:H.</infon><infon key="name_1">surname:Vahid Dastjerdi;given-names:A.</infon><infon key="name_2">surname:Ghosh;given-names:S.K.</infon><infon key="name_3">surname:Buyya;given-names:R.</infon><infon key="pub-id_doi">10.1002/spe.2509</infon><infon key="section_type">REF</infon><infon key="source">Softw. Prac. Exp.</infon><infon key="type">ref</infon><infon key="volume">47</infon><infon key="year">2017</infon><offset>36614</offset><text>iFogSim: A toolkit for modeling and simulation of resource management techniques in the Internet of Things, Edge and Fog computing environments</text></passage><passage><infon key="fpage">39</infon><infon key="lpage">44</infon><infon key="name_0">surname:Sonmez;given-names:C.</infon><infon key="name_1">surname:Ozgovde;given-names:A.</infon><infon key="name_2">surname:Ersoy;given-names:C.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2017 Second International Conference on Fog and Mobile Edge Computing (FMEC)</infon><infon key="type">ref</infon><infon key="volume">Volume 5</infon><offset>36758</offset><text>EdgeCloudSim: An environment for performance evaluation of Edge Computing systems</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">8</infon><infon key="name_0">surname:Xu;given-names:Q.</infon><infon key="name_1">surname:Zhang;given-names:J.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2019 IEEE 38th International Performance Computing and Communications Conference (IPCCC)</infon><infon key="type">ref</infon><offset>36840</offset><text>piFogBed: A Fog Computing Testbed Based on Raspberry Pi</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">10</infon><infon key="name_0">surname:Varga;given-names:A.</infon><infon key="name_1">surname:Hornig;given-names:R.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 1st International Conference on Simulation Tools and Techniques for Communications, Networks and Systems &amp; Workshops</infon><infon key="type">ref</infon><offset>36896</offset><text>An overview of the OMNeT++ simulation environment</text></passage><passage><infon key="fpage">23</infon><infon key="lpage">50</infon><infon key="name_0">surname:Calheiros;given-names:R.N.</infon><infon key="name_1">surname:Ranjan;given-names:R.</infon><infon key="name_2">surname:Beloglazov;given-names:A.</infon><infon key="name_3">surname:De Rose;given-names:C.A.</infon><infon key="name_4">surname:Buyya;given-names:R.</infon><infon key="pub-id_doi">10.1002/spe.995</infon><infon key="section_type">REF</infon><infon key="source">Softw. Prac. Exp.</infon><infon key="type">ref</infon><infon key="volume">41</infon><infon key="year">2011</infon><offset>36946</offset><text>CloudSim: A toolkit for modeling and simulation of cloud computing environments and evaluation of resource provisioning algorithms</text></passage><passage><infon key="fpage">2018</infon><infon key="name_0">surname:Moysiadis;given-names:V.</infon><infon key="name_1">surname:Sarigiannidis;given-names:P.</infon><infon key="name_2">surname:Moscholios;given-names:I.</infon><infon key="pub-id_doi">10.1155/2018/7597686</infon><infon key="section_type">REF</infon><infon key="source">Wirel. Com. Mob. Comput.</infon><infon key="type">ref</infon><offset>37077</offset><text>Towards distributed data management in fog computing</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">8</infon><infon key="name_0">surname:Naas;given-names:M.I.</infon><infon key="name_1">surname:Boukhobza;given-names:J.</infon><infon key="name_2">surname:Parvedy;given-names:P.R.</infon><infon key="name_3">surname:Lemarchand;given-names:L.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2018 IEEE 2nd International Conference on Fog and Edge Computing (ICFEC)</infon><infon key="type">ref</infon><offset>37130</offset><text>An extension to ifogsim to enable the design of data placement strategies</text></passage><passage><infon key="name_0">surname:WANG;given-names:Q.</infon><infon key="section_type">REF</infon><infon key="source">Ph.D. Thesis</infon><infon key="type">ref</infon><infon key="year">2019</infon><offset>37204</offset><text>PFogSim: A Simulator for Evaluating Dynamic and Layered Fog Computing Environments</text></passage><passage><infon key="name_0">surname:Zeng;given-names:X.</infon><infon key="name_1">surname:Garg;given-names:S.K.</infon><infon key="name_2">surname:Strazdins;given-names:P.</infon><infon key="name_3">surname:Jayaraman;given-names:P.</infon><infon key="name_4">surname:Georgakopoulos;given-names:D.</infon><infon key="name_5">surname:Ranjan;given-names:R.</infon><infon key="pub-id_arxiv">1602.06488</infon><infon key="section_type">REF</infon><infon key="source">arXiv</infon><infon key="type">ref</infon><infon key="year">2016</infon><offset>37287</offset><text>IOTSim: A Cloud based Simulator for Analysing IoT Applications</text></passage><passage><infon key="fpage">105</infon><infon key="lpage">114</infon><infon key="name_0">surname:Brogi;given-names:A.</infon><infon key="name_1">surname:Forti;given-names:S.</infon><infon key="name_2">surname:Ibrahim;given-names:A.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2017 IEEE 1st International Conference on Fog and Edge Computing (ICFEC)</infon><infon key="type">ref</infon><offset>37350</offset><text>How to best deploy your Fog applications, probably</text></passage><passage><infon key="fpage">1185</infon><infon key="lpage">1192</infon><infon key="name_0">surname:Brogi;given-names:A.</infon><infon key="name_1">surname:Forti;given-names:S.</infon><infon key="pub-id_doi">10.1109/JIOT.2017.2701408</infon><infon key="section_type">REF</infon><infon key="source">IEEE Internet Things J.</infon><infon key="type">ref</infon><infon key="volume">4</infon><infon key="year">2017</infon><offset>37401</offset><text>QoS-aware deployment of IoT applications through the fog</text></passage><passage><infon key="fpage">4568</infon><infon key="lpage">4569</infon><infon key="name_0">surname:Byrne;given-names:J.</infon><infon key="name_1">surname:Svorobej;given-names:S.</infon><infon key="name_2">surname:Gourinovitch;given-names:A.</infon><infon key="name_3">surname:Elango;given-names:D.M.</infon><infon key="name_4">surname:Liston;given-names:P.</infon><infon key="name_5">surname:Byrne;given-names:P.J.</infon><infon key="name_6">surname:Lynn;given-names:T.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2017 Winter Simulation Conference (WSC)</infon><infon key="type">ref</infon><offset>37458</offset><text>Recap simulator: Simulation of cloud/edge/fog computing scenarios</text></passage><passage><infon key="elocation-id">1160</infon><infon key="name_0">surname:Scarpiniti;given-names:M.</infon><infon key="name_1">surname:Baccarelli;given-names:E.</infon><infon key="name_2">surname:Momenzadeh;given-names:A.</infon><infon key="pub-id_doi">10.3390/app9061160</infon><infon key="section_type">REF</infon><infon key="source">Appl. Sci.</infon><infon key="type">ref</infon><infon key="volume">9</infon><infon key="year">2019</infon><offset>37524</offset><text>VirtFogSim: A parallel toolbox for dynamic energy-delay performance testing and optimization of 5G mobile-fog-cloud virtualized platforms</text></passage><passage><infon key="fpage">101966</infon><infon key="name_0">surname:Fernández-Cerero;given-names:D.</infon><infon key="name_1">surname:Fernández-Montes;given-names:A.</infon><infon key="name_2">surname:Ortega;given-names:F.J.</infon><infon key="name_3">surname:Jakóbik;given-names:A.</infon><infon key="name_4">surname:Widlak;given-names:A.</infon><infon key="pub-id_doi">10.1016/j.simpat.2019.101966</infon><infon key="section_type">REF</infon><infon key="source">Simul. Model. Pract. Theory</infon><infon key="type">ref</infon><infon key="volume">101</infon><infon key="year">2020</infon><offset>37662</offset><text>Sphere: Simulator of edge infrastructures for the optimization of performance and resources energy consumption</text></passage><passage><infon key="fpage">160</infon><infon key="lpage">173</infon><infon key="name_0">surname:Fernández-Cerero;given-names:D.</infon><infon key="name_1">surname:Fernández-Montes;given-names:A.</infon><infon key="name_2">surname:Jaköbik;given-names:A.</infon><infon key="name_3">surname:Kołodziej;given-names:J.</infon><infon key="name_4">surname:Toro;given-names:M.</infon><infon key="pub-id_doi">10.1016/j.simpat.2018.01.004</infon><infon key="section_type">REF</infon><infon key="source">Simul. Model. Pract. Theory</infon><infon key="type">ref</infon><infon key="volume">82</infon><infon key="year">2018</infon><offset>37773</offset><text>Score: Simulator for cloud optimization of resources and energy consumption</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">6</infon><infon key="name_0">surname:Mayer;given-names:R.</infon><infon key="name_1">surname:Graser;given-names:L.</infon><infon key="name_2">surname:Gupta;given-names:H.</infon><infon key="name_3">surname:Saurez;given-names:E.</infon><infon key="name_4">surname:Ramachandran;given-names:U.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2017 IEEE Fog World Congress (FWC)</infon><infon key="type">ref</infon><offset>37849</offset><text>EmuFog: Extensible and scalable emulation of Large-Scale fog computing infrastructures</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">7</infon><infon key="name_0">surname:Coutinho;given-names:A.</infon><infon key="name_1">surname:Greve;given-names:F.</infon><infon key="name_2">surname:Prazeres;given-names:C.</infon><infon key="name_3">surname:Cardoso;given-names:J.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2018 IEEE International Conference on Communications (ICC)</infon><infon key="type">ref</infon><offset>37936</offset><text>Fogbed: A rapid-prototyping emulation environment for fog computing</text></passage><passage><infon key="fpage">1</infon><infon key="lpage">6</infon><infon key="name_0">surname:Gedawy;given-names:H.</infon><infon key="name_1">surname:Tariq;given-names:S.</infon><infon key="name_2">surname:Mtibaa;given-names:A.</infon><infon key="name_3">surname:Harras;given-names:K.</infon><infon key="section_type">REF</infon><infon key="source">Proceedings of the 2016 Cloudification of the Internet of Things (CIoT)</infon><infon key="type">ref</infon><offset>38004</offset><text>Cumulus: A distributed and flexible computing testbed for edge cloud computational offloading</text></passage><passage><infon key="fpage">2296</infon><infon key="lpage">2319</infon><infon key="name_0">surname:Li;given-names:G.</infon><infon key="name_1">surname:Wang;given-names:J.</infon><infon key="name_2">surname:Zheng;given-names:Y.</infon><infon key="name_3">surname:Franklin;given-names:M.J.</infon><infon key="pub-id_doi">10.1109/TKDE.2016.2535242</infon><infon key="section_type">REF</infon><infon key="source">IEEE Trans. Knowl. Data Eng.</infon><infon key="type">ref</infon><infon key="volume">28</infon><infon key="year">2016</infon><offset>38098</offset><text>Crowdsourced data management: A survey</text></passage><passage><infon key="fpage">90</infon><infon key="lpage">102</infon><infon key="name_0">surname:Xie;given-names:H.</infon><infon key="name_1">surname:Lui;given-names:J.C.S.</infon><infon key="pub-id_doi">10.1109/TSC.2016.2539954</infon><infon key="section_type">REF</infon><infon key="source">IEEE Trans. Serv. Comput.</infon><infon key="type">ref</infon><infon key="volume">11</infon><infon key="year">2016</infon><offset>38137</offset><text>Incentive mechanism and rating system design for crowdsourcing systems: Analysis, tradeoffs and inference</text></passage><passage><infon key="comment">Available online: https://ieeexplore.ieee.org/abstract/document/8668576</infon><infon key="name_0">surname:Li;given-names:Y.</infon><infon key="name_1">surname:Xu;given-names:W.</infon><infon key="name_2">surname:Yiu;given-names:M.L.</infon><infon key="section_type">REF</infon><infon key="source">IEEE Trans. Serv. Comput.</infon><infon key="type">ref</infon><infon key="year">2019</infon><offset>38243</offset><text>Client-side Service for Recommending Rewarding Routes to Mobile Crowdsourcing Workers</text></passage><passage><infon key="comment">Available online: http://mqtt.org</infon><infon key="section_type">REF</infon><infon key="type">ref</infon><offset>38329</offset><text>MQTT</text></passage><passage><infon key="comment">Available online: https://github.com/apache/activemq-apollo/tree/trunk/apollo-mqtt</infon><infon key="section_type">REF</infon><infon key="type">ref</infon><offset>38334</offset><text>Apollo</text></passage><passage><infon key="file">sensors-20-01900-g001.jpg</infon><infon key="id">sensors-20-01900-f001</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38341</offset><text>Logical components of piFogBedII.</text></passage><passage><infon key="file">sensors-20-01900-g002.jpg</infon><infon key="id">sensors-20-01900-f002</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38375</offset><text>Component interactions in each stage of an experiment.</text></passage><passage><infon key="file">sensors-20-01900-g003.jpg</infon><infon key="id">sensors-20-01900-f003</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38430</offset><text>Key data structure used in piFogBedII.</text></passage><passage><infon key="file">sensors-20-01900-g004.jpg</infon><infon key="id">sensors-20-01900-f004</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38469</offset><text>Migration process of an end device.</text></passage><passage><infon key="file">sensors-20-01900-g005.jpg</infon><infon key="id">sensors-20-01900-f005</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38505</offset><text>Functions of container agent.</text></passage><passage><infon key="file">sensors-20-01900-g006.jpg</infon><infon key="id">sensors-20-01900-f006</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38535</offset><text>Values of each attribute.</text></passage><passage><infon key="file">sensors-20-01900-g007.jpg</infon><infon key="id">sensors-20-01900-f007</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38561</offset><text>Publish–subscribe model based on active push.</text></passage><passage><infon key="file">sensors-20-01900-g008.jpg</infon><infon key="id">sensors-20-01900-f008</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38609</offset><text>Mobile route of the end device.</text></passage><passage><infon key="file">sensors-20-01900-g009.jpg</infon><infon key="id">sensors-20-01900-f009</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38641</offset><text>Migration time at different positions.</text></passage><passage><infon key="file">sensors-20-01900-g010.jpg</infon><infon key="id">sensors-20-01900-f010</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38680</offset><text>Compare of access directly and by container agent on delay time under different thread numbers.</text></passage><passage><infon key="file">sensors-20-01900-g011.jpg</infon><infon key="id">sensors-20-01900-f011</infon><infon key="section_type">FIG</infon><infon key="type">fig_caption</infon><offset>38776</offset><text>Comparison of access directly and via container agent on delay time under different data amounts.</text></passage></document></collection>
